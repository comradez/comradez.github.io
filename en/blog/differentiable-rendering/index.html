<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- JS for KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <title>Chris Zhang&#x27;s Blog | Research Notes: Differentiable Rendering</title>
    
    <link rel="stylesheet" href="https://blog.zcy.moe/style.css?h=05ce8a9f27c3f6647cbb">
    
</head>
<body>
    
<header class="space">
    
        <a href="https:&#x2F;&#x2F;blog.zcy.moe/en">&LeftArrow; Home</a>
    
</header>

    
<main>
    <h1>Research Notes: Differentiable Rendering</h1>

    
    <div class="post-meta">











<span title="2022-11-15 12:06:36 +0000">November 15, 2022</span>&nbsp;·&nbsp;茨月
</div>
    

    <div class="space"></div>
    <p>This post discusses the basics of differentiable rendering and is primarily a reading note from the SIGGRAPH 2020 Course.</p>
<span id="continue-reading"></span>
<p>This note comes from the course <a href="https://dl.acm.org/doi/abs/10.1145/3388769.3407454"><em>Physics-based differentiable rendering: from theory to implementation</em></a>. The notes mainly focus on the theoretical derivations, as I’m not currently working on differentiable rendering, so the parts related to the rendering equation can be revisited later.</p>
<p>For more on automatic differentiation in rendering, you can also refer to Yzu-Mao Li's paper <a href="https://people.csail.mit.edu/sbangaru/projects/teg-2021/"><em>Systematically Differentiating Parametric Discontinuities</em></a> published in SIGGRAPH 2021. The author implemented a Python DSL for autodiff <del>why does everyone love Python so much</del>, which might be helpful for autodiff in Luisa IR.</p>
<h2 id="what-is-differentiable-rendering">What is Differentiable Rendering?</h2>
<p>Given all parameters \(\mathbb\pi\), rendering produces an image \(I(\mathbf\pi)\), and the loss function with respect to the ground truth image is \(L\). The goal of differentiable rendering is to compute \(\nabla_{\mathbf\pi}L(I(\mathbf\pi))\), enabling gradient-based optimization of rendering results for inverse rendering.</p>
<p>For any parameter \(\pi\) in \(\mathbf{\pi}\), we have:
$$
\frac{\partial}{\partial\pi}L(I(\mathbf\pi)) = \sum_i\frac{\partial L}{\partial I_i(\mathbf{\pi})}\frac{\partial I_i(\mathbf{\pi})}{\partial\pi}
$$
The first term is straightforward. For example, for the basic MSE Loss:
$$
L = \left(I(\mathbf\pi) - \hat I(\mathbf\pi)\right)^2
$$</p>
<p>$$
\frac{\partial L}{\partial I(\mathbf{\pi})} = 2\left(I(\mathbf\pi) - \hat I(\mathbf\pi)\right)
$$</p>
<p>The challenge lies in computing the latter term, \(\frac{\partial I_i(\mathbf{\pi})}{\partial\pi}\).</p>
<h2 id="can-rendering-be-made-differentiable-painlessly">Can Rendering Be Made Differentiable "Painlessly"?</h2>
<img alt="Two triangles" id="should-invert" src="/images/differentiable_rendering/0.webp"/>
<p>Rendering is essentially an integration problem. Take a simple anti-aliasing example: if each pixel is sampled at only one point, the result will have many jagged edges (high-frequency noise). One solution is to apply a low-pass filter, i.e., compute the integral over a region around the sampling center for each pixel:
$$
I_i(\mathbf\pi) = \iint k(x,y)m(x_i+x, y_i+y; \mathbf\pi)\text{d}x\text{d}y = \iint f(x, y; \mathbf\pi)\text{d}x\text{d}y
$$
where \(k\) is the convolution kernel, \(m\) is the continuous image space, and \(I\) is the discrete image. In practice, renderers typically use the following method (familiar as "Multisample Anti-Aliasing, MSAA") to numerically approximate this integral:
$$
\iint f(x, y; \mathbf\pi)\text{d}x\text{d}y \approx \frac{1}{N}\sum_{j=1}^N f(x_j, y_j; \pi)
$$
This numerical integration solves the computation of the integral but <strong>does not solve</strong> the differentiation of the integral:
$$
\frac{\partial}{\partial \pi_v}\iint f(x, y; \mathbf\pi)\text{d}x\text{d}y \not\approx \frac{1}{N}\sum_{j=1}^N \frac{\partial}{\partial \pi_v}f(x_j, y_j; \mathbf\pi) = 0
$$</p>
<blockquote>
<p>Why is the derivative of discrete sampling always 0?</p>
<p>The value of \(f(x_j, y_j; \mathbf\pi)\) is "the color of the object hit at this point." If the triangle hit doesn’t change when \(\pi_v\) changes, the gradient is necessarily 0; if it crosses a boundary, the gradient is theoretically infinite—but the probability of discrete sampling hitting the boundary is 0, so this term can be ignored.</p>
</blockquote>
<p>Since differentiation is essentially about local changes, discrete sampling is insensitive to such changes, making direct differentiation of numerical integration infeasible. Consider a simpler example:
$$
\frac{\partial}{\partial p}\int_0^1(x &lt; p\ ?\ 1:0) \text{d}x
$$
Discrete sampling will always yield 0, while the actual result is 1 (since the integral is simply \(p\)).</p>
<h2 id="how-to-differentiate-this-integral">How to Differentiate This Integral?</h2>
<p>To compute the derivative of the integral of a discrete univariate function, first list all its discontinuities, then compute the derivatives of the continuous parts and the discontinuities separately.</p>
<img alt="Integral" id="should-invert" src="/images/differentiable_rendering/1.webp"/>
<p>For example, for the above integral:
$$
\frac{\partial}{\partial p}\int_0^1(x &lt; p\ ?\ 1:0) \text{d}x = \frac{\partial}{\partial p}\int_0^p 1\text{d}x + \frac{\partial}{\partial p}\int_p^1 0\text{d}x
$$
Then compute each part separately. Generally:
$$
\frac{\partial}{\partial\pi}\int_{a(\pi)}^{b(\pi)}f(x;\mathbf\pi)\text{d}x=\int_{a(\pi)}^{b(\pi)}\frac{\partial}{\partial\pi}f(x;\mathbf\pi)\text{d}x + \left[\frac{\partial b(\pi)}{\partial\pi}f(b(\pi); \mathbf\pi) - \frac{\partial a(\pi)}{\partial\pi}f(a(\pi); \mathbf\pi)\right]
$$
The first term is the internal contribution, and the second term is the boundary compensation.</p>
<h2 id="extending-to-higher-dimensions">Extending to Higher Dimensions...</h2>
<p>Let \(f\) be a function defined on an \(n\)-dimensional manifold \(\Omega(\pi)\), and \(\Gamma(\pi) \subset \Omega(\pi)\) be an \(n-1\)-dimensional manifold containing the external boundary \(\partial\Omega(\pi)\) and the boundaries between different regions within \(\Omega(\pi)\). Then, the derivative of the integral of \(f\) over \(\Omega(\pi)\) can be expressed as:
$$
\frac{\partial}{\partial\pi}\left(\int_\Omega f\text{d}\Omega\right) = \int_\Omega\dot f \text{d}\Omega + \int_\Gamma\left\langle\mathbf{n}, \dot x\right\rangle \Delta f\text{d}\Gamma
$$
where:
$$
\dot f = \frac{\partial f}{\partial\pi}
$$
$$
\dot x = \frac{\partial x}{\partial\pi} \
$$
$$
\Delta f(x) = \lim_{\epsilon\to0^-}f(x+\epsilon \mathbf n) - \lim_{\epsilon\to0^+}f(x+\epsilon \mathbf n)
$$
Here, \(\dot x\) represents the direction of boundary movement as the parameter \(\pi\) changes. The two parts of the integral can be approximated numerically:
$$
\int_\Omega\dot f \text{d}\Omega \approx \frac{1}{N_i}\sum_{j=1}^{N_i}\dot f(x_j)
$$
$$
\int_\Gamma\left\langle\mathbf{n}, \dot x\right\rangle \Delta f\text{d}\Gamma \approx \frac{1}{N_b}\sum_{j=1}^{N_b}\left\langle\mathbf{n}, \dot x\right\rangle\Delta f(x_j)
$$
Thus, we’ve addressed the theoretical problem of differentiable rendering...</p>

</main>

    <div class="dark-mode-buttons">
        <button class="dark-mode-button" id="dark-mode-on"><img src="https://blog.zcy.moe/dark_mode.svg" width="24" height="24" alt=""></button>
        <button class="dark-mode-button" id="dark-mode-off"><img src="https://blog.zcy.moe/light_mode.svg" width="24" height="24" alt=""></button>
    </div>
    <div class="language-switch-buttons">
        <button class="language-switch-button" id="language-switch-dark-on"><img src="https://blog.zcy.moe/translation_dark.svg" width="24" height="24" alt=""></button>
        <button class="language-switch-button" id="language-switch-dark-off"><img src="https://blog.zcy.moe/translation_light.svg" width="24" height="24" alt=""></button>
        <ul class="language-dropdown">
            <li class="language-option" id="switch-to-en">English</li>
            <li class="language-option" id="switch-to-zh-cn">中文</li>
        </ul>
    </div>
    <div id="action-botton">
        <div class="action-wrapper">
            <div class="action meter">
                <span id="progress_meter">JS</span>
            </div>
            <a href="#top" class="action up no-dot">
                <svg xmlns='http://www.w3.org/2000/svg' class='icon' viewBox='0 0 512 512'><title>Arrow Up</title><path fill='none' stroke='currentColor' stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M112 244l144-144 144 144M256 120v292'/></svg>
            </a>
        </div>
    </div>
    <!-- JS for light/dark switch, minified -->
    <script>const cls=document.body.classList;const getSessionTheme=sessionStorage.getItem("theme");if(getSessionTheme==="dark"){cls.toggle("dark-mode",true)}else if(getSessionTheme==="light"){cls.toggle("dark-mode",false)}else if(window.matchMedia("(prefers-color-scheme: dark)").matches){cls.toggle("dark-mode",true)}document.getElementById("dark-mode-on").addEventListener("click",function(e){cls.toggle("dark-mode",true);sessionStorage.setItem("theme","dark")});document.getElementById("dark-mode-off").addEventListener("click",function(e){cls.toggle("dark-mode",false);sessionStorage.setItem("theme","light")});</script>
    <!-- JS for progress meter, minified -->
    <script type="text/javascript">let progress_meter=document.getElementById("progress_meter"),height=document.body.scrollHeight-screen.height,last_position=window.scrollY;function update_progress_meter(){height=document.body.clientHeight-window.innerHeight,current_position=window.scrollY,progress=Math.ceil(current_position/height*100),height==0?progress=100:progress<0?progress=0:progress>100&&(progress=100),progress_meter.innerText=(progress==100?"End":(progress+"%"))}let ticking=!1;window.addEventListener('scroll',function(a){ticking||(window.requestAnimationFrame(function(){update_progress_meter(),ticking=!1}),ticking=!0)}),progress_meter.style.textDecoration='none',update_progress_meter()</script>
    <!-- JS for language toggle, minified -->
    <script type="text/javascript">let toggle_language=function(lang_code){return function(){const currentUrl=window.location.href;const url=new URL(currentUrl);const path=url.pathname;if(!path.startsWith(`/${ lang_code }`)){const newPath=`/${ lang_code }${ path }`;const newUrl=`${url.origin }${ newPath }${url.search }${url.hash }`;window.location.href=newUrl}}};let toggle_default_language=function(){const currentUrl=window.location.href;const url=new URL(currentUrl);const path=url.pathname;const possible_lang_codes=['en'];const lang_code=path.split("/")[1];if(possible_lang_codes.includes(lang_code)){const newPath=path.replace(`/${ lang_code }`,'');const newUrl=`${url.origin }${ newPath }${url.search }${url.hash }`;window.location.href=newUrl}};document.getElementById('switch-to-en').addEventListener('click',toggle_language('en'));document.getElementById('switch-to-zh-cn').addEventListener('click',toggle_default_language);</script>
    <noscript>
        <style>
            .dark-mode-buttons {
                display: none;
            }
        </style>
    </noscript>
</body>
</html>
