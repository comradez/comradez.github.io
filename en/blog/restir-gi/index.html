<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- JS for KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <title>Chris Zhang&#x27;s Blog | Paper Note: ReSTIR GI: Path Resampling for Real-Time Path Tracing</title>
    
    <link rel="stylesheet" href="https://blog.zcy.moe/style.css?h=05ce8a9f27c3f6647cbb">
    
</head>
<body>
    
<header class="space">
    
        <a href="https:&#x2F;&#x2F;blog.zcy.moe/en">&LeftArrow; Home</a>
    
</header>

    
<main>
    <h1>Paper Note: ReSTIR GI: Path Resampling for Real-Time Path Tracing</h1>

    
    <div class="post-meta">











<span title="2023-08-06 23:19:44 +0000">August 6, 2023</span>&nbsp;·&nbsp;茨月
</div>
    

    <div class="space"></div>
    <p>This article discusses <strong>ReSTIR GI</strong>, an algorithm that uses the ReSTIR method to maintain probe sampling for handling 1-bounce global illumination.</p>
<span id="continue-reading"></span><h2 id="preface">Preface</h2>
<p>This work extends the ReSTIR sampler, enabling ReSTIR to be applied to global illumination. The article is relatively simple and short, and it doesn’t introduce much theoretical innovation (which might be why it was published in HPG instead of SIGGRAPH).</p>
<blockquote>
<p>Update as of Dec. 2024</p>
<p>I don't mean to undermean the contribution of this work. It has been used in the latest AAA games and is both very effective and efficient with diffuse GI. However on a research perspective, I view it more like a "porting this onto that" follow-up-ish work.</p>
</blockquote>
<p>In simple terms, the algorithm first generates a G-Buffer containing the spatial positions and local normals of visible points for each pixel (via rasterization or ray tracing for direct lighting). Then, from each visible point, it randomly samples an incident point for indirect light as a sample point, and happily applies ReSTIR to these sample points.</p>
<p>Interestingly, the target distribution for ReSTIR GI sampling can be very simple (e.g., directly set as \(\hat p\propto L_o(x_s,-\omega_i)\), without including BRDF or cosine terms) and still achieve good results. The authors explain that a simple target distribution makes the samples generated by one pixel more effective for other pixels. Additionally, since the \(L_o\) of the sample point is cached, the authors have to assume that \(L_o\) remains unchanged when the sample point connects to different visible points—this assumption is false when the sample point is in non-diffuse media, and artifacts may occur if the scene contains many glossy surfaces.</p>
<h2 id="algorithm-workflow">Algorithm Workflow</h2>
<p>Unlike ReSTIR DI, ReSTIR GI requires maintaining three image-sized buffers: one for storing the initial samples generated in the current round (<strong>initial sample buffer</strong>), one for the temporal reservoir from the previous round (<strong>temporal reservoir buffer</strong>), and one for storing neighboring pixel sampling information (<strong>spatial reservoir buffer</strong>).</p>
<p>The <code>SAMPLE</code> data structure for each pixel is defined as follows, and each buffer consists of <code>width * height</code> <code>SAMPLE</code> instances.</p>
<div class="side-by-side-container">
<img src="/images/restir_gi/sample.webp" id="should-invert"  alt="Layout of the SAMPLE data structure for each pixel" style="zoom: 12.5%;" />
</div>
<p>To perform ReSTIR GI calculations, the algorithm first needs a G-Buffer that stores the positions and normals of the shading points (called visible points) for each pixel. Each round of the algorithm consists of three steps:</p>
<ul>
<li>Initial Sampling</li>
<li>Temporal Resampling</li>
<li>Spatial Resampling</li>
</ul>
<p>The overall workflow of the algorithm can be described by these two diagrams:</p>
<div class="side-by-side-container">
<img src="/images/restir_gi/dataflow.webp" id="should-invert"  alt="Dataflow of the whole algorithm" style="zoom: 12.5%;" />
</div>
<div class="side-by-side-container">
<img src="/images/restir_gi/alogrithm.webp" id="should-invert"  alt="the process of the algorithm" style="zoom: 12.5%;" />
</div>
<h3 id="initial-sampling">Initial Sampling</h3>
<p>From each visible point, sample a direction \(\omega_i\) using the initial distribution \(p_q\). \(p_q\) can be a very crude distribution, such as BRDF, cosine-weighted, or even uniform sampling. Trace from the visible point \(x_v\) in the direction \(\omega_i\) to obtain the intersection point \(x_s\), which serves as the sample point for pixel \(q\).</p>
<p>Next, the algorithm estimates the outgoing radiance \(L_o\) from \(x_s\) in the direction \(-\omega_i\) (toward \(x_v\)) as the indirect illumination received by \(x_v\). If \(L_o\) is computed using direct lighting, the algorithm yields 1-bounce GI; if \(L_o\) is computed using \(n\)-bounce PT with NEE, the algorithm yields \(n+1\)-bounce GI. Note that \(L_o\) is stored as a single value without direction, so when \(x_s\) connects to other pixels’ \(x_v\), the same value is used—this assumes that \(L_o\) is the same in different directions.</p>
<p>The results of the initial sampling are stored in the initial sample buffer.</p>
<p>The pseudocode for initial sampling is as follows:</p>
<div class="side-by-side-container">
<img src="/images/restir_gi/initial_sampling.webp" id="should-invert"  alt="pseudocode for initial sampling" style="zoom: 12.5%;" />
</div>
<h3 id="temporal-resampling">Temporal Resampling</h3>
<p>To perform resampling, the target distribution \(\hat p\) must first be determined. It can be the ideal \(\hat p\propto L_o(x_s,\omega_i)f(\omega_o,\omega_i)\langle\cos\theta_i\rangle\) (similar to ReSTIR DI) or the simpler \(\hat p\propto L_o(x_s,\omega_i)\).</p>
<p>Temporal resampling simply takes the temporal reservoir buffer, mixes it with the corresponding reservoir in the initial sample buffer, and places it back in its original position. The pseudocode is as follows:</p>
<div class="side-by-side-container">
<img src="/images/restir_gi/temporal_sampling.webp" id="should-invert"  alt="pseudocode for temporal sampling" style="zoom: 12.5%;" />
</div>
<h3 id="spatial-resampling">Spatial Resampling</h3>
<p>Spatial resampling is more complex because it considers geometric differences between neighboring pixels. Therefore, it cannot directly take sample points from adjacent pixels in the temporal reservoir buffer and mix them. Two additional points need to be considered:</p>
<ul>
<li>
<p>If the geometric difference between two pixels is too large, the sample is discarded, similar to ReSTIR DI.</p>
</li>
<li>
<p>When resampling a sample point from pixel \(r\) to pixel \(q\), since the probability of generating a sample to the same sample point from two visible points is different, the corresponding weight needs to be divided by a Jacobian Determinant [this part comes from <a href="https://dl.acm.org/doi/10.1145/2766997">Gradient-domain Path Tracing</a>, and I didn’t understand why it’s calculated this way] to compensate.</p>
</li>
</ul>
<p>The formula for the Jacobian Determinant is:
$$
|J_{q\to r}| = \frac{\cos\phi_2^r}{\cos\phi_2^q}\cdot\frac{|x_1^q-x_2^q|}{|x_1^r - x_2^q|}
$$
where \(x_1^*\) represents the visible point, and \(x_2^*\) represents the sample point. The diagram is as follows:</p>
<div class="side-by-side-container">
<img src="/images/restir_gi/jacobian_determinant.webp" id="should-invert" style="zoom: 12.5%;" />
</div>
<p>The pseudocode, considering the above two points, is as follows:</p>
<div class="side-by-side-container">
<img src="/images/restir_gi/spatial_resampling.webp" id="should-invert"  alt="pseudocode for spatial sampling" style="zoom: 30%;" />
</div>
<p>Additionally, to avoid bias accumulation from repeated sampling, ReSTIR GI prioritizes sampling from the temporal reservoir buffer of neighboring pixels during multiple spatial resampling steps. If the number of samples is insufficient, it then samples from the spatial reservoir buffer.</p>

</main>

    <div class="dark-mode-buttons">
        <button class="dark-mode-button" id="dark-mode-on"><img src="https://blog.zcy.moe/dark_mode.svg" width="24" height="24" alt=""></button>
        <button class="dark-mode-button" id="dark-mode-off"><img src="https://blog.zcy.moe/light_mode.svg" width="24" height="24" alt=""></button>
    </div>
    <div class="language-switch-buttons">
        <button class="language-switch-button" id="language-switch-dark-on"><img src="https://blog.zcy.moe/translation_dark.svg" width="24" height="24" alt=""></button>
        <button class="language-switch-button" id="language-switch-dark-off"><img src="https://blog.zcy.moe/translation_light.svg" width="24" height="24" alt=""></button>
        <ul class="language-dropdown">
            <li class="language-option" id="switch-to-en">English</li>
            <li class="language-option" id="switch-to-zh-cn">中文</li>
        </ul>
    </div>
    <div id="action-botton">
        <div class="action-wrapper">
            <div class="action meter">
                <span id="progress_meter">JS</span>
            </div>
            <a href="#top" class="action up no-dot">
                <svg xmlns='http://www.w3.org/2000/svg' class='icon' viewBox='0 0 512 512'><title>Arrow Up</title><path fill='none' stroke='currentColor' stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M112 244l144-144 144 144M256 120v292'/></svg>
            </a>
        </div>
    </div>
    <!-- JS for light/dark switch, minified -->
    <script>const cls=document.body.classList;const getSessionTheme=sessionStorage.getItem("theme");if(getSessionTheme==="dark"){cls.toggle("dark-mode",true)}else if(getSessionTheme==="light"){cls.toggle("dark-mode",false)}else if(window.matchMedia("(prefers-color-scheme: dark)").matches){cls.toggle("dark-mode",true)}document.getElementById("dark-mode-on").addEventListener("click",function(e){cls.toggle("dark-mode",true);sessionStorage.setItem("theme","dark")});document.getElementById("dark-mode-off").addEventListener("click",function(e){cls.toggle("dark-mode",false);sessionStorage.setItem("theme","light")});</script>
    <!-- JS for progress meter, minified -->
    <script type="text/javascript">let progress_meter=document.getElementById("progress_meter"),height=document.body.scrollHeight-screen.height,last_position=window.scrollY;function update_progress_meter(){height=document.body.clientHeight-window.innerHeight,current_position=window.scrollY,progress=Math.ceil(current_position/height*100),height==0?progress=100:progress<0?progress=0:progress>100&&(progress=100),progress_meter.innerText=(progress==100?"End":(progress+"%"))}let ticking=!1;window.addEventListener('scroll',function(a){ticking||(window.requestAnimationFrame(function(){update_progress_meter(),ticking=!1}),ticking=!0)}),progress_meter.style.textDecoration='none',update_progress_meter()</script>
    <!-- JS for language toggle, minified -->
    <script type="text/javascript">let toggle_language=function(lang_code){return function(){const currentUrl=window.location.href;const url=new URL(currentUrl);const path=url.pathname;if(!path.startsWith(`/${ lang_code }`)){const newPath=`/${ lang_code }${ path }`;const newUrl=`${url.origin }${ newPath }${url.search }${url.hash }`;window.location.href=newUrl}}};let toggle_default_language=function(){const currentUrl=window.location.href;const url=new URL(currentUrl);const path=url.pathname;const possible_lang_codes=['en'];const lang_code=path.split("/")[1];if(possible_lang_codes.includes(lang_code)){const newPath=path.replace(`/${ lang_code }`,'');const newUrl=`${url.origin }${ newPath }${url.search }${url.hash }`;window.location.href=newUrl}};document.getElementById('switch-to-en').addEventListener('click',toggle_language('en'));document.getElementById('switch-to-zh-cn').addEventListener('click',toggle_default_language);</script>
    <noscript>
        <style>
            .dark-mode-buttons {
                display: none;
            }
        </style>
    </noscript>
</body>
</html>
